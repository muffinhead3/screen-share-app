<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìƒë‹´ì‚¬ í™”ë©´</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; color: #fff; }
        .header { background: rgba(255,255,255,0.1); padding: 15px 30px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 1.5rem; font-weight: bold; color: #4fc3f7; }
        .header-right { display: flex; align-items: center; gap: 15px; }
        .connection-count { background: rgba(79, 195, 247, 0.2); color: #4fc3f7; padding: 6px 12px; border-radius: 15px; font-size: 0.85rem; display: flex; align-items: center; gap: 6px; }
        .connection-count .count { font-weight: bold; font-size: 1rem; }
        .status-badge { padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .status-badge.waiting { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .status-badge.connected { background: rgba(76, 175, 80, 0.2); color: #4caf50; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; animation: pulse 2s infinite; }
        .waiting .status-dot { background: #ffc107; }
        .connected .status-dot { background: #4caf50; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .container { display: flex; height: calc(100vh - 70px); }
        .sidebar { width: 320px; background: rgba(255,255,255,0.05); padding: 20px; overflow-y: auto; border-right: 1px solid rgba(255,255,255,0.1); }
        .main-content { flex: 1; display: flex; flex-direction: column; padding: 20px; overflow: hidden; }
        .section { background: rgba(255,255,255,0.08); border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .section-title { font-size: 1rem; color: #4fc3f7; margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .btn { width: 100%; padding: 12px 20px; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%); color: #fff; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(33, 150, 243, 0.4); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }
        .btn-success { background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); color: #fff; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4); }
        .btn-danger { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); color: #fff; }
        .btn-danger:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(244, 67, 54, 0.4); }
        .btn-warning { background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); color: #fff; }
        .btn-warning:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(255, 152, 0, 0.4); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .share-link-container { display: none; margin-top: 15px; }
        .share-link-container.active { display: block; }
        .share-link-box { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 10px; }
        .share-link-label { font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .share-link { color: #4fc3f7; word-break: break-all; font-size: 0.9rem; }
        .file-upload-area { border: 2px dashed rgba(255,255,255,0.3); border-radius: 12px; padding: 30px; text-align: center; cursor: pointer; transition: all 0.3s; margin-bottom: 15px; }
        .file-upload-area:hover { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.1); }
        .file-upload-area.dragover { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.2); }
        .file-upload-icon { font-size: 3rem; margin-bottom: 10px; }
        .file-upload-text { color: #888; }
        .file-types { font-size: 0.75rem; color: #666; margin-top: 8px; }
        #fileInput { display: none; }
        .current-file { display: none; background: rgba(76, 175, 80, 0.1); border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px; }
        .current-file.active { display: flex; align-items: center; gap: 10px; }
        .current-file-icon { color: #4caf50; font-size: 1.5rem; }
        .current-file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .tools-container { display: flex; gap: 10px; flex-wrap: wrap; }
        .tool-btn { width: 45px; height: 45px; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s; background: rgba(255,255,255,0.1); border: 2px solid transparent; font-size: 1.2rem; }
        .tool-btn:hover { background: rgba(255,255,255,0.2); }
        .tool-btn.active { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.2); }
        /* ê·¸ë¼ë°ì´ì…˜ ìƒ‰ìƒ ì„ íƒê¸° */
        .color-picker-wrapper { position: relative; width: 45px; height: 45px; }
        .color-picker-display { 
            width: 45px; height: 45px; border-radius: 50%; cursor: pointer; 
            background: conic-gradient(red, yellow, lime, aqua, blue, magenta, red);
            border: 3px solid rgba(255,255,255,0.3);
            transition: all 0.3s;
            display: flex; align-items: center; justify-content: center;
        }
        .color-picker-display:hover { border-color: #fff; transform: scale(1.1); }
        .color-picker-inner { 
            width: 20px; height: 20px; border-radius: 50%; 
            border: 2px solid #fff; 
        }
        #colorPicker { position: absolute; width: 45px; height: 45px; opacity: 0; cursor: pointer; top: 0; left: 0; }
        /* ëª¨ìì´í¬ ë²„íŠ¼ */
        .blur-btn {
            background: linear-gradient(135deg, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0.1) 100%);
            position: relative;
            overflow: hidden;
        }
        .blur-btn::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 30px; height: 30px;
            background: repeating-linear-gradient(
                45deg,
                rgba(255,255,255,0.4),
                rgba(255,255,255,0.4) 3px,
                rgba(100,100,100,0.4) 3px,
                rgba(100,100,100,0.4) 6px
            );
            border-radius: 4px;
            filter: blur(1px);
        }
        .stroke-width-container { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .stroke-width-label { font-size: 0.9rem; color: #888; }
        .stroke-width-slider { flex: 1; height: 6px; -webkit-appearance: none; background: rgba(255,255,255,0.2); border-radius: 3px; }
        .stroke-width-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #4fc3f7; border-radius: 50%; cursor: pointer; }
        .action-buttons { display: flex; flex-direction: column; gap: 10px; margin-top: 15px; }
        .pdf-viewer-container { flex: 1; display: flex; flex-direction: column; background: rgba(255,255,255,0.05); border-radius: 12px; overflow: hidden; }
        .pdf-toolbar { display: flex; align-items: center; justify-content: center; gap: 15px; padding: 15px; background: rgba(0,0,0,0.3); flex-wrap: wrap; }
        .toolbar-group { display: flex; align-items: center; gap: 10px; }
        .toolbar-divider { width: 1px; height: 30px; background: rgba(255,255,255,0.2); margin: 0 5px; }
        .page-nav-btn { width: 40px; height: 40px; border-radius: 8px; background: rgba(255,255,255,0.1); border: none; color: #fff; cursor: pointer; font-size: 1.2rem; transition: all 0.3s; }
        .page-nav-btn:hover:not(:disabled) { background: rgba(255,255,255,0.2); }
        .page-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .page-info { font-size: 1rem; color: #fff; min-width: 80px; text-align: center; }
        .zoom-btn { width: 36px; height: 36px; border-radius: 8px; background: rgba(255,255,255,0.1); border: none; color: #fff; cursor: pointer; font-size: 1.2rem; transition: all 0.3s; }
        .zoom-btn:hover { background: rgba(255,255,255,0.2); }
        .zoom-info { font-size: 0.9rem; color: #4fc3f7; min-width: 60px; text-align: center; font-weight: bold; }
        .pdf-canvas-container { flex: 1; display: flex; align-items: center; justify-content: center; overflow: auto; padding: 20px; position: relative; }
        .canvas-wrapper { position: relative; display: inline-block; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        #pdfCanvas { display: block; background: #fff; }
        #drawCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; }
        .start-screen { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        .start-screen-icon { font-size: 5rem; margin-bottom: 20px; opacity: 0.5; }
        .start-screen-text { font-size: 1.2rem; color: #888; margin-bottom: 10px; }
        .start-screen-subtext { font-size: 0.9rem; color: #666; }
        .toast { position: fixed; bottom: 30px; right: 30px; background: rgba(0,0,0,0.9); color: #fff; padding: 15px 25px; border-radius: 10px; display: flex; align-items: center; gap: 10px; transform: translateY(100px); opacity: 0; transition: all 0.3s; z-index: 1000; }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-left: 4px solid #4caf50; }
        .toast.info { border-left: 4px solid #2196f3; }
        .toast.warning { border-left: 4px solid #ff9800; }
        .zoom-note { font-size: 0.75rem; color: #888; text-align: center; margin-top: 5px; }
        .eraser-cursor { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="white" stroke="black" stroke-width="2"/></svg>') 10 10, auto; }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">ğŸ“ ìƒë‹´ í™”ë©´ ê³µìœ </div>
        <div class="header-right">
            <div id="connectionCount" class="connection-count" style="display: none;">
                <span>ğŸ‘¥</span>
                <span>ì ‘ì†ì:</span>
                <span id="countNumber" class="count">0</span>
                <span>ëª…</span>
            </div>
            <div id="statusBadge" class="status-badge waiting">
                <div class="status-dot"></div>
                <span id="statusText">ëŒ€ê¸° ì¤‘</span>
            </div>
        </div>
    </header>
    
    <div class="container">
        <aside class="sidebar">
            <div class="section">
                <div class="section-title"><span>ğŸ”—</span> ì„¸ì…˜ ê´€ë¦¬</div>
                <button id="createSessionBtn" class="btn btn-primary"><span>â•</span> ìƒˆ ìƒë‹´ ì„¸ì…˜ ì‹œì‘</button>
                <div id="shareLinkContainer" class="share-link-container">
                    <div class="share-link-box">
                        <div class="share-link-label">ê³ ê° ê³µìœ  ë§í¬</div>
                        <div id="shareLink" class="share-link"></div>
                    </div>
                    <button id="copyLinkBtn" class="btn btn-secondary"><span>ğŸ“‹</span> ë§í¬ ë³µì‚¬í•˜ê¸°</button>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title"><span>ğŸ“„</span> íŒŒì¼ ê³µìœ </div>
                <div id="currentFile" class="current-file">
                    <span class="current-file-icon">âœ…</span>
                    <span id="currentFileName" class="current-file-name"></span>
                </div>
                <div id="fileUploadArea" class="file-upload-area">
                    <div class="file-upload-icon">ğŸ“</div>
                    <div class="file-upload-text">íŒŒì¼ì„ ì—¬ê¸°ì— ëŒì–´ë‹¤ ë†“ê±°ë‚˜<br>í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</div>
                    <div class="file-types">ì§€ì›: PDF, JPG, PNG, GIF</div>
                </div>
                <input type="file" id="fileInput" accept="application/pdf,image/jpeg,image/png,image/gif">
            </div>
            
            <div class="section">
                <div class="section-title"><span>ğŸ¨</span> ì£¼ì„ ë„êµ¬</div>
                <div class="tools-container">
                    <button id="pointerTool" class="tool-btn active" title="í¬ì¸í„°">ğŸ‘†</button>
                    <button id="penTool" class="tool-btn" title="íœ">âœï¸</button>
                    <button id="highlighterTool" class="tool-btn" title="í˜•ê´‘íœ">ğŸ–ï¸</button>
                    <button id="rectangleTool" class="tool-btn" title="ì‚¬ê°í˜•">â¬œ</button>
                    <button id="circleTool" class="tool-btn" title="ì›">â­•</button>
                    <button id="blurTool" class="tool-btn blur-btn" title="ëª¨ìì´í¬"></button>
                    <div class="color-picker-wrapper">
                        <div class="color-picker-display" title="ìƒ‰ìƒ ì„ íƒ">
                            <div id="colorPickerInner" class="color-picker-inner" style="background: #ff0000;"></div>
                        </div>
                        <input type="color" id="colorPicker" value="#ff0000" title="ìƒ‰ìƒ ì„ íƒ">
                    </div>
                </div>
                <div class="stroke-width-container">
                    <span class="stroke-width-label">êµµê¸°:</span>
                    <input type="range" id="strokeWidth" class="stroke-width-slider" min="1" max="20" value="3">
                    <span id="strokeWidthValue">3px</span>
                </div>
                
                <div class="action-buttons">
                    <button id="eraserBtn" class="btn btn-warning"><span>ğŸ§½</span> ì§€ìš°ê°œ</button>
                    <button id="undoBtn" class="btn btn-secondary"><span>â†©ï¸</span> ë˜ëŒë¦¬ê¸°</button>
                    <button id="clearBtn" class="btn btn-danger"><span>ğŸ—‘ï¸</span> ì „ì²´ ì§€ìš°ê¸°</button>
                    <button id="captureBtn" class="btn btn-success"><span>ğŸ“¸</span> í™”ë©´ ìº¡ì²˜ ì €ì¥</button>
                </div>
            </div>
        </aside>
        
        <main class="main-content">
            <div id="startScreen" class="start-screen">
                <div class="start-screen-icon">ğŸ“‘</div>
                <div class="start-screen-text">íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
                <div class="start-screen-subtext">ì™¼ìª½ì—ì„œ ì„¸ì…˜ì„ ìƒì„±í•˜ê³  íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”</div>
            </div>
            
            <div id="pdfViewerContainer" class="pdf-viewer-container" style="display: none;">
                <div class="pdf-toolbar">
                    <div class="toolbar-group">
                        <button id="prevPageBtn" class="page-nav-btn" disabled>â—€</button>
                        <span id="pageInfo" class="page-info">1 / 1</span>
                        <button id="nextPageBtn" class="page-nav-btn" disabled>â–¶</button>
                    </div>
                    <div class="toolbar-divider"></div>
                    <div class="toolbar-group">
                        <button id="zoomOutBtn" class="zoom-btn" title="ì¶•ì†Œ">â–</button>
                        <span id="zoomInfo" class="zoom-info">100%</span>
                        <button id="zoomInBtn" class="zoom-btn" title="í™•ëŒ€">â•</button>
                        <button id="zoomResetBtn" class="zoom-btn" title="ì›ë˜ í¬ê¸°" style="font-size: 0.8rem;">100</button>
                    </div>
                </div>
                <div class="zoom-note">ğŸ’¡ ì¤Œì€ ë‚´ í™”ë©´ì—ì„œë§Œ ì ìš©ë©ë‹ˆë‹¤ (ê³ ê° í™”ë©´ê³¼ ë…ë¦½)</div>
                <div class="pdf-canvas-container">
                    <div class="canvas-wrapper">
                        <canvas id="pdfCanvas"></canvas>
                        <canvas id="drawCanvas"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        let socket = null;
        let sessionId = null;
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 1;
        let currentTool = 'pointer';
        let isDrawing = false;
        let drawHistory = [];
        let currentPath = [];
        let startX, startY;
        let currentFileType = null;
        let currentImage = null;
        let currentZoom = 1.0;
        let isEraserMode = false;
        let customerCount = 0;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;
        const ZOOM_STEP = 0.25;
        const ERASER_SIZE = 20;
        const BLUR_SIZE = 10;
        
        const pdfCanvas = document.getElementById('pdfCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        // ìƒ‰ìƒ ì„ íƒê¸° ì—…ë°ì´íŠ¸
        const colorPicker = document.getElementById('colorPicker');
        const colorPickerInner = document.getElementById('colorPickerInner');
        colorPicker.addEventListener('input', (e) => {
            colorPickerInner.style.background = e.target.value;
        });
        
        function toRatio(x, y) {
            return { x: x / drawCanvas.width, y: y / drawCanvas.height };
        }
        
        function fromRatio(rx, ry) {
            return { x: rx * drawCanvas.width, y: ry * drawCanvas.height };
        }
        
        function pathToRatio(path) {
            return path.map(p => toRatio(p.x, p.y));
        }
        
        function pathFromRatio(ratioPath) {
            return ratioPath.map(p => fromRatio(p.x, p.y));
        }
        
        function updateZoomInfo() {
            document.getElementById('zoomInfo').textContent = `${Math.round(currentZoom * 100)}%`;
        }
        
        function updateConnectionCount(count) {
            customerCount = count;
            const countEl = document.getElementById('connectionCount');
            const countNum = document.getElementById('countNumber');
            countNum.textContent = count;
            countEl.style.display = 'flex';
        }
        
        function initSocket() {
            socket = io();
            socket.on('connect', () => {
                console.log('ì„œë²„ ì—°ê²°ë¨');
                if (sessionId) {
                    socket.emit('join-session', { sessionId, role: 'consultant' });
                }
            });
            socket.on('user-joined', (data) => {
                if (data.role === 'customer') {
                    updateStatus('connected', 'ê³ ê° ì—°ê²°ë¨');
                    showToast('ê³ ê°ì´ ì ‘ì†í–ˆìŠµë‹ˆë‹¤!', 'success');
                }
            });
            socket.on('user-left', (data) => {
                if (data.role === 'customer') {
                    if (customerCount <= 1) {
                        updateStatus('waiting', 'ëŒ€ê¸° ì¤‘');
                    }
                    showToast('ê³ ê° ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤', 'warning');
                }
            });
            socket.on('customer-count', (data) => {
                updateConnectionCount(data.count);
                if (data.count > 0) {
                    updateStatus('connected', 'ê³ ê° ì—°ê²°ë¨');
                } else {
                    updateStatus('waiting', 'ëŒ€ê¸° ì¤‘');
                }
            });
        }
        
        document.getElementById('createSessionBtn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/create-session', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    sessionId = data.sessionId;
                    document.getElementById('shareLink').textContent = data.shareUrl;
                    document.getElementById('shareLinkContainer').classList.add('active');
                    initSocket();
                    socket.emit('join-session', { sessionId, role: 'consultant' });
                    showToast('ì„¸ì…˜ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                    document.getElementById('createSessionBtn').disabled = true;
                    document.getElementById('createSessionBtn').innerHTML = '<span>âœ…</span> ì„¸ì…˜ í™œì„±í™”ë¨';
                    document.getElementById('connectionCount').style.display = 'flex';
                }
            } catch (error) {
                console.error('ì„¸ì…˜ ìƒì„± ì˜¤ë¥˜:', error);
                showToast('ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'warning');
            }
        });
        
        document.getElementById('copyLinkBtn').addEventListener('click', () => {
            const link = document.getElementById('shareLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                showToast('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            });
        });
        
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');
        
        fileUploadArea.addEventListener('click', () => fileInput.click());
        fileUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); fileUploadArea.classList.add('dragover'); });
        fileUploadArea.addEventListener('dragleave', () => { fileUploadArea.classList.remove('dragover'); });
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file);
        });
        fileInput.addEventListener('change', (e) => { if (e.target.files[0]) handleFileUpload(e.target.files[0]); });
        
        function handleFileUpload(file) {
            const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/gif'];
            if (!allowedTypes.includes(file.type)) {
                showToast('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤', 'warning');
                return;
            }
            
            if (file.type === 'application/pdf') {
                uploadFile(file, 'pdf');
            } else {
                uploadFile(file, 'image');
            }
        }
        
        async function uploadFile(file, type) {
            if (!sessionId) {
                showToast('ë¨¼ì € ì„¸ì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            formData.append('fileType', type);
            try {
                showToast('íŒŒì¼ ì—…ë¡œë“œ ì¤‘...', 'info');
                const response = await fetch(`/api/upload-file/${sessionId}`, { method: 'POST', body: formData });
                const data = await response.json();
                if (data.success) {
                    document.getElementById('currentFile').classList.add('active');
                    document.getElementById('currentFileName').textContent = file.name;
                    currentFileType = type;
                    drawHistory = [];
                    currentZoom = 1.0;
                    updateZoomInfo();
                    
                    if (type === 'pdf') {
                        await loadPDF(data.fileUrl);
                    } else {
                        await loadImage(data.fileUrl);
                    }
                    showToast('íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                }
            } catch (error) {
                console.error('íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
                showToast('íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'warning');
            }
        }
        
        async function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    currentImage = img;
                    pdfDoc = null;
                    totalPages = 1;
                    currentPage = 1;
                    document.getElementById('startScreen').style.display = 'none';
                    document.getElementById('pdfViewerContainer').style.display = 'flex';
                    renderImage();
                    updatePageInfo();
                    resolve();
                };
                img.onerror = reject;
                img.src = url;
            });
        }
        
        function renderImage() {
            if (!currentImage) return;
            
            let width = currentImage.width * currentZoom;
            let height = currentImage.height * currentZoom;
            
            pdfCanvas.width = width;
            pdfCanvas.height = height;
            drawCanvas.width = width;
            drawCanvas.height = height;
            
            pdfCtx.drawImage(currentImage, 0, 0, width, height);
            redrawAll();
        }
        
        async function loadPDF(url) {
            try {
                pdfDoc = await pdfjsLib.getDocument(url).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                currentImage = null;
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('pdfViewerContainer').style.display = 'flex';
                await renderPage(currentPage);
                updatePageInfo();
            } catch (error) {
                console.error('PDF ë¡œë“œ ì˜¤ë¥˜:', error);
                showToast('PDFë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'warning');
            }
        }
        
        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const scale = 1.5 * currentZoom;
            const viewport = page.getViewport({ scale });
            pdfCanvas.width = viewport.width;
            pdfCanvas.height = viewport.height;
            drawCanvas.width = viewport.width;
            drawCanvas.height = viewport.height;
            await page.render({ canvasContext: pdfCtx, viewport: viewport }).promise;
            redrawAll();
        }
        
        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `${currentPage} / ${totalPages}`;
            document.getElementById('prevPageBtn').disabled = currentPage <= 1 || currentFileType === 'image';
            document.getElementById('nextPageBtn').disabled = currentPage >= totalPages || currentFileType === 'image';
        }
        
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            if (currentZoom < MAX_ZOOM) {
                currentZoom = Math.min(currentZoom + ZOOM_STEP, MAX_ZOOM);
                applyZoom();
            }
        });
        
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            if (currentZoom > MIN_ZOOM) {
                currentZoom = Math.max(currentZoom - ZOOM_STEP, MIN_ZOOM);
                applyZoom();
            }
        });
        
        document.getElementById('zoomResetBtn').addEventListener('click', () => {
            currentZoom = 1.0;
            applyZoom();
        });
        
        function applyZoom() {
            updateZoomInfo();
            
            if (currentFileType === 'image' && currentImage) {
                renderImage();
            } else if (pdfDoc) {
                renderPage(currentPage);
            }
        }
        
        document.getElementById('prevPageBtn').addEventListener('click', () => {
            if (currentPage > 1 && currentFileType === 'pdf') {
                currentPage--;
                drawHistory = [];
                renderPage(currentPage);
                updatePageInfo();
                socket.emit('page-change', { sessionId, page: currentPage, totalPages });
            }
        });
        
        document.getElementById('nextPageBtn').addEventListener('click', () => {
            if (currentPage < totalPages && currentFileType === 'pdf') {
                currentPage++;
                drawHistory = [];
                renderPage(currentPage);
                updatePageInfo();
                socket.emit('page-change', { sessionId, page: currentPage, totalPages });
            }
        });
        
        const toolButtons = {
            pointer: document.getElementById('pointerTool'),
            pen: document.getElementById('penTool'),
            highlighter: document.getElementById('highlighterTool'),
            rectangle: document.getElementById('rectangleTool'),
            circle: document.getElementById('circleTool'),
            blur: document.getElementById('blurTool')
        };
        
        const eraserBtn = document.getElementById('eraserBtn');
        
        // ì§€ìš°ê°œ ë²„íŠ¼ í† ê¸€
        eraserBtn.addEventListener('click', () => {
            isEraserMode = !isEraserMode;
            
            if (isEraserMode) {
                eraserBtn.style.background = 'linear-gradient(135deg, #e65100 0%, #bf360c 100%)';
                eraserBtn.innerHTML = '<span>ğŸ§½</span> ì§€ìš°ê°œ ì‚¬ìš© ì¤‘';
                currentTool = 'eraser';
                Object.values(toolButtons).forEach(b => b.classList.remove('active'));
                drawCanvas.style.cursor = 'none';
                drawCanvas.classList.add('eraser-cursor');
            } else {
                eraserBtn.style.background = '';
                eraserBtn.innerHTML = '<span>ğŸ§½</span> ì§€ìš°ê°œ';
                currentTool = 'pointer';
                toolButtons.pointer.classList.add('active');
                drawCanvas.style.cursor = 'default';
                drawCanvas.classList.remove('eraser-cursor');
            }
        });
        
        Object.entries(toolButtons).forEach(([tool, btn]) => {
            btn.addEventListener('click', () => {
                // ì§€ìš°ê°œ ëª¨ë“œ í•´ì œ
                isEraserMode = false;
                eraserBtn.style.background = '';
                eraserBtn.innerHTML = '<span>ğŸ§½</span> ì§€ìš°ê°œ';
                drawCanvas.classList.remove('eraser-cursor');
                
                currentTool = tool;
                Object.values(toolButtons).forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (tool === 'pointer') {
                    drawCanvas.style.cursor = 'default';
                } else {
                    drawCanvas.style.cursor = 'crosshair';
                }
            });
        });
        
        const strokeWidth = document.getElementById('strokeWidth');
        const strokeWidthValue = document.getElementById('strokeWidthValue');
        strokeWidth.addEventListener('input', (e) => { strokeWidthValue.textContent = `${e.target.value}px`; });
        
        function getCanvasCoords(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }
        
        drawCanvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'pointer') return;
            isDrawing = true;
            const coords = getCanvasCoords(e);
            startX = coords.x;
            startY = coords.y;
            currentPath = [{ x: startX, y: startY }];
            
            if (currentTool === 'eraser') {
                eraseAt(coords.x, coords.y);
                socket.emit('eraser-start', { sessionId, x: toRatio(coords.x, coords.y).x, y: toRatio(coords.x, coords.y).y });
            } else if (currentTool === 'blur') {
                // ë¸”ëŸ¬ëŠ” mouseupì—ì„œ ì²˜ë¦¬
            } else {
                const startRatio = toRatio(startX, startY);
                socket.emit('draw-start', { 
                    sessionId, 
                    tool: currentTool, 
                    color: colorPicker.value, 
                    width: parseInt(strokeWidth.value), 
                    x: startRatio.x, 
                    y: startRatio.y 
                });
            }
        });
        
        drawCanvas.addEventListener('mousemove', (e) => {
            const coords = getCanvasCoords(e);
            
            if (currentTool === 'pointer' && sessionId) {
                const ratio = toRatio(coords.x, coords.y);
                socket.emit('pointer-move', { sessionId, x: ratio.x, y: ratio.y, visible: true });
            }
            
            if (!isDrawing) return;
            
            if (currentTool === 'eraser') {
                eraseAt(coords.x, coords.y);
                currentPath.push({ x: coords.x, y: coords.y });
                socket.emit('erasing', { sessionId, path: pathToRatio(currentPath) });
            } else if (currentTool === 'blur') {
                // ë¸”ëŸ¬ ì˜ì—­ í”„ë¦¬ë·°
                redrawAll();
                drawCtx.save();
                drawCtx.strokeStyle = 'rgba(128, 128, 128, 0.8)';
                drawCtx.lineWidth = 2;
                drawCtx.setLineDash([5, 5]);
                drawCtx.strokeRect(startX, startY, coords.x - startX, coords.y - startY);
                drawCtx.restore();
            } else {
                const color = colorPicker.value;
                const width = parseInt(strokeWidth.value);
                
                if (currentTool === 'pen' || currentTool === 'highlighter') {
                    currentPath.push({ x: coords.x, y: coords.y });
                    redrawAll();
                    drawCtx.beginPath();
                    drawCtx.strokeStyle = currentTool === 'highlighter' ? hexToRgba(color, 0.3) : color;
                    drawCtx.lineWidth = currentTool === 'highlighter' ? width * 3 : width;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.moveTo(currentPath[0].x, currentPath[0].y);
                    for (let i = 1; i < currentPath.length; i++) {
                        drawCtx.lineTo(currentPath[i].x, currentPath[i].y);
                    }
                    drawCtx.stroke();
                    
                    socket.emit('drawing', { 
                        sessionId, 
                        path: pathToRatio(currentPath), 
                        tool: currentTool, 
                        color: color, 
                        width: width 
                    });
                } else if (currentTool === 'rectangle' || currentTool === 'circle') {
                    redrawAll();
                    drawShape(startX, startY, coords.x, coords.y, currentTool, color, width, true);
                }
            }
        });
        
        drawCanvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            const coords = getCanvasCoords(e);
            const color = colorPicker.value;
            const width = parseInt(strokeWidth.value);
            
            if (currentTool === 'eraser') {
                const eraserData = { tool: 'eraser', path: pathToRatio(currentPath) };
                drawHistory.push(eraserData);
                socket.emit('eraser-end', { sessionId, eraserData });
            } else if (currentTool === 'blur') {
                // ë¸”ëŸ¬ ì˜ì—­ ì ìš©
                const x = Math.min(startX, coords.x);
                const y = Math.min(startY, coords.y);
                const w = Math.abs(coords.x - startX);
                const h = Math.abs(coords.y - startY);
                
                if (w > 5 && h > 5) {
                    applyBlur(x, y, w, h);
                    
                    const startRatio = toRatio(x, y);
                    const endRatio = toRatio(x + w, y + h);
                    const blurData = {
                        tool: 'blur',
                        startX: startRatio.x,
                        startY: startRatio.y,
                        endX: endRatio.x,
                        endY: endRatio.y
                    };
                    drawHistory.push(blurData);
                    socket.emit('draw-end', { sessionId, drawingData: blurData });
                }
            } else {
                let drawingData = { tool: currentTool, color: color, width: width };
                
                if (currentTool === 'pen' || currentTool === 'highlighter') {
                    drawingData.path = pathToRatio(currentPath);
                } else {
                    const startRatio = toRatio(startX, startY);
                    const endRatio = toRatio(coords.x, coords.y);
                    drawingData.startX = startRatio.x;
                    drawingData.startY = startRatio.y;
                    drawingData.endX = endRatio.x;
                    drawingData.endY = endRatio.y;
                }
                
                drawHistory.push(drawingData);
                redrawAll();
                socket.emit('draw-end', { sessionId, drawingData });
            }
        });
        
        drawCanvas.addEventListener('mouseleave', () => {
            if (currentTool === 'pointer' && sessionId) {
                socket.emit('pointer-move', { sessionId, x: 0, y: 0, visible: false });
            }
        });
        
        function eraseAt(x, y) {
            drawCtx.save();
            drawCtx.globalCompositeOperation = 'destination-out';
            drawCtx.beginPath();
            drawCtx.arc(x, y, ERASER_SIZE, 0, Math.PI * 2);
            drawCtx.fill();
            drawCtx.restore();
        }
        
        function applyBlur(x, y, w, h) {
            // ëª¨ìì´í¬ íš¨ê³¼ ì ìš©
            const pixelSize = 10;
            
            // PDF ìº”ë²„ìŠ¤ì—ì„œ í•´ë‹¹ ì˜ì—­ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
            const imageData = pdfCtx.getImageData(x, y, w, h);
            
            // ëª¨ìì´í¬ ì²˜ë¦¬
            for (let py = 0; py < h; py += pixelSize) {
                for (let px = 0; px < w; px += pixelSize) {
                    let r = 0, g = 0, b = 0, count = 0;
                    
                    // ë¸”ë¡ ë‚´ í‰ê·  ìƒ‰ìƒ ê³„ì‚°
                    for (let dy = 0; dy < pixelSize && py + dy < h; dy++) {
                        for (let dx = 0; dx < pixelSize && px + dx < w; dx++) {
                            const idx = ((py + dy) * w + (px + dx)) * 4;
                            r += imageData.data[idx];
                            g += imageData.data[idx + 1];
                            b += imageData.data[idx + 2];
                            count++;
                        }
                    }
                    
                    r = Math.floor(r / count);
                    g = Math.floor(g / count);
                    b = Math.floor(b / count);
                    
                    // ë¸”ë¡ì— í‰ê·  ìƒ‰ìƒ ì ìš©
                    for (let dy = 0; dy < pixelSize && py + dy < h; dy++) {
                        for (let dx = 0; dx < pixelSize && px + dx < w; dx++) {
                            const idx = ((py + dy) * w + (px + dx)) * 4;
                            imageData.data[idx] = r;
                            imageData.data[idx + 1] = g;
                            imageData.data[idx + 2] = b;
                        }
                    }
                }
            }
            
            // ëª¨ìì´í¬ ì²˜ë¦¬ëœ ì´ë¯¸ì§€ë¥¼ ê·¸ë¦¬ê¸° ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = w;
            tempCanvas.height = h;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            drawCtx.drawImage(tempCanvas, x, y);
        }
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawShape(x1, y1, x2, y2, shape, color, width, preview = false) {
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = width;
            drawCtx.lineCap = 'round';
            if (shape === 'rectangle') {
                drawCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            } else if (shape === 'circle') {
                const radiusX = Math.abs(x2 - x1) / 2;
                const radiusY = Math.abs(y2 - y1) / 2;
                const centerX = x1 + (x2 - x1) / 2;
                const centerY = y1 + (y2 - y1) / 2;
                drawCtx.beginPath();
                drawCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                drawCtx.stroke();
            }
        }
        
        function redrawAll() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            for (const item of drawHistory) {
                if (item.tool === 'eraser') {
                    const realPath = pathFromRatio(item.path);
                    drawCtx.save();
                    drawCtx.globalCompositeOperation = 'destination-out';
                    for (const point of realPath) {
                        drawCtx.beginPath();
                        drawCtx.arc(point.x, point.y, ERASER_SIZE, 0, Math.PI * 2);
                        drawCtx.fill();
                    }
                    drawCtx.restore();
                } else if (item.tool === 'blur') {
                    const start = fromRatio(item.startX, item.startY);
                    const end = fromRatio(item.endX, item.endY);
                    const x = Math.min(start.x, end.x);
                    const y = Math.min(start.y, end.y);
                    const w = Math.abs(end.x - start.x);
                    const h = Math.abs(end.y - start.y);
                    applyBlur(x, y, w, h);
                } else if (item.tool === 'pen' || item.tool === 'highlighter') {
                    const realPath = pathFromRatio(item.path);
                    drawCtx.beginPath();
                    drawCtx.strokeStyle = item.tool === 'highlighter' ? hexToRgba(item.color, 0.3) : item.color;
                    drawCtx.lineWidth = item.tool === 'highlighter' ? item.width * 3 : item.width;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.moveTo(realPath[0].x, realPath[0].y);
                    for (let i = 1; i < realPath.length; i++) {
                        drawCtx.lineTo(realPath[i].x, realPath[i].y);
                    }
                    drawCtx.stroke();
                } else {
                    const start = fromRatio(item.startX, item.startY);
                    const end = fromRatio(item.endX, item.endY);
                    drawShape(start.x, start.y, end.x, end.y, item.tool, item.color, item.width);
                }
            }
        }
        
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (drawHistory.length > 0) {
                drawHistory.pop();
                redrawAll();
                socket.emit('undo-drawing', { sessionId });
            }
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            drawHistory = [];
            redrawAll();
            socket.emit('clear-drawings', { sessionId });
        });
        
        document.getElementById('captureBtn').addEventListener('click', () => {
            captureScreen();
        });
        
        function captureScreen() {
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = pdfCanvas.width;
            captureCanvas.height = pdfCanvas.height;
            const captureCtx = captureCanvas.getContext('2d');
            
            captureCtx.drawImage(pdfCanvas, 0, 0);
            captureCtx.drawImage(drawCanvas, 0, 0);
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `ìƒë‹´í™”ë©´_${timestamp}.png`;
            link.href = captureCanvas.toDataURL('image/png');
            link.click();
            
            showToast('í™”ë©´ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
        }
        
        function updateStatus(status, text) {
            const badge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            badge.className = `status-badge ${status}`;
            statusText.textContent = text;
        }
        
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
    </script>
</body>
</html>
