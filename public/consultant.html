<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìƒë‹´ì‚¬ í™”ë©´</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; color: #fff; }
        .header { background: rgba(255,255,255,0.1); padding: 15px 30px; display: flex; justify-content: space-between; align-items: center; }
        .logo { font-size: 1.5rem; font-weight: bold; color: #4fc3f7; }
        .status-badge { padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .status-badge.waiting { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .status-badge.connected { background: rgba(76, 175, 80, 0.2); color: #4caf50; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; animation: pulse 2s infinite; }
        .waiting .status-dot { background: #ffc107; }
        .connected .status-dot { background: #4caf50; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .container { display: flex; height: calc(100vh - 70px); }
        .sidebar { width: 320px; background: rgba(255,255,255,0.05); padding: 20px; overflow-y: auto; border-right: 1px solid rgba(255,255,255,0.1); }
        .main-content { flex: 1; display: flex; flex-direction: column; padding: 20px; overflow: hidden; }
        .section { background: rgba(255,255,255,0.08); border-radius: 12px; padding: 20px; margin-bottom: 20px; }
        .section-title { font-size: 1rem; color: #4fc3f7; margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .btn { width: 100%; padding: 12px 20px; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .btn-primary { background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%); color: #fff; }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(33, 150, 243, 0.4); }
        .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); }
        .btn-secondary:hover { background: rgba(255,255,255,0.2); }
        .btn-success { background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); color: #fff; }
        .btn-success:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4); }
        .btn-danger { background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%); color: #fff; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .share-link-container { display: none; margin-top: 15px; }
        .share-link-container.active { display: block; }
        .share-link-box { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 12px; margin-bottom: 10px; }
        .share-link-label { font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .share-link { color: #4fc3f7; word-break: break-all; font-size: 0.9rem; }
        .file-upload-area { border: 2px dashed rgba(255,255,255,0.3); border-radius: 12px; padding: 30px; text-align: center; cursor: pointer; transition: all 0.3s; margin-bottom: 15px; }
        .file-upload-area:hover { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.1); }
        .file-upload-area.dragover { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.2); }
        .file-upload-icon { font-size: 3rem; margin-bottom: 10px; }
        .file-upload-text { color: #888; }
        .file-types { font-size: 0.75rem; color: #666; margin-top: 8px; }
        #fileInput { display: none; }
        .current-file { display: none; background: rgba(76, 175, 80, 0.1); border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 15px; }
        .current-file.active { display: flex; align-items: center; gap: 10px; }
        .current-file-icon { color: #4caf50; font-size: 1.5rem; }
        .current-file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .tools-container { display: flex; gap: 10px; flex-wrap: wrap; }
        .tool-btn { width: 45px; height: 45px; border-radius: 10px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s; background: rgba(255,255,255,0.1); border: 2px solid transparent; font-size: 1.2rem; }
        .tool-btn:hover { background: rgba(255,255,255,0.2); }
        .tool-btn.active { border-color: #4fc3f7; background: rgba(79, 195, 247, 0.2); }
        .color-picker { width: 45px; height: 45px; border-radius: 10px; border: 2px solid rgba(255,255,255,0.3); cursor: pointer; padding: 0; }
        .stroke-width-container { display: flex; align-items: center; gap: 10px; margin-top: 10px; }
        .stroke-width-label { font-size: 0.9rem; color: #888; }
        .stroke-width-slider { flex: 1; height: 6px; -webkit-appearance: none; background: rgba(255,255,255,0.2); border-radius: 3px; }
        .stroke-width-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #4fc3f7; border-radius: 50%; cursor: pointer; }
        .pdf-viewer-container { flex: 1; display: flex; flex-direction: column; background: rgba(255,255,255,0.05); border-radius: 12px; overflow: hidden; }
        .pdf-toolbar { display: flex; align-items: center; justify-content: center; gap: 15px; padding: 15px; background: rgba(0,0,0,0.3); }
        .page-nav-btn { width: 40px; height: 40px; border-radius: 8px; background: rgba(255,255,255,0.1); border: none; color: #fff; cursor: pointer; font-size: 1.2rem; transition: all 0.3s; }
        .page-nav-btn:hover:not(:disabled) { background: rgba(255,255,255,0.2); }
        .page-nav-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .page-info { font-size: 1rem; color: #fff; min-width: 100px; text-align: center; }
        .pdf-canvas-container { flex: 1; display: flex; align-items: center; justify-content: center; overflow: auto; padding: 20px; position: relative; }
        .canvas-wrapper { position: relative; display: inline-block; box-shadow: 0 10px 40px rgba(0,0,0,0.3); }
        #pdfCanvas { display: block; background: #fff; }
        #drawCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; }
        .start-screen { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        .start-screen-icon { font-size: 5rem; margin-bottom: 20px; opacity: 0.5; }
        .start-screen-text { font-size: 1.2rem; color: #888; margin-bottom: 10px; }
        .start-screen-subtext { font-size: 0.9rem; color: #666; }
        .toast { position: fixed; bottom: 30px; right: 30px; background: rgba(0,0,0,0.9); color: #fff; padding: 15px 25px; border-radius: 10px; display: flex; align-items: center; gap: 10px; transform: translateY(100px); opacity: 0; transition: all 0.3s; z-index: 1000; }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-left: 4px solid #4caf50; }
        .toast.info { border-left: 4px solid #2196f3; }
        .toast.warning { border-left: 4px solid #ff9800; }
        .capture-section { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">ğŸ“ ìƒë‹´ í™”ë©´ ê³µìœ </div>
        <div id="statusBadge" class="status-badge waiting">
            <div class="status-dot"></div>
            <span id="statusText">ëŒ€ê¸° ì¤‘</span>
        </div>
    </header>
    
    <div class="container">
        <aside class="sidebar">
            <div class="section">
                <div class="section-title"><span>ğŸ”—</span> ì„¸ì…˜ ê´€ë¦¬</div>
                <button id="createSessionBtn" class="btn btn-primary"><span>â•</span> ìƒˆ ìƒë‹´ ì„¸ì…˜ ì‹œì‘</button>
                <div id="shareLinkContainer" class="share-link-container">
                    <div class="share-link-box">
                        <div class="share-link-label">ê³ ê° ê³µìœ  ë§í¬</div>
                        <div id="shareLink" class="share-link"></div>
                    </div>
                    <button id="copyLinkBtn" class="btn btn-secondary"><span>ğŸ“‹</span> ë§í¬ ë³µì‚¬í•˜ê¸°</button>
                </div>
            </div>
            
            <div class="section">
                <div class="section-title"><span>ğŸ“„</span> íŒŒì¼ ê³µìœ </div>
                <div id="currentFile" class="current-file">
                    <span class="current-file-icon">âœ…</span>
                    <span id="currentFileName" class="current-file-name"></span>
                </div>
                <div id="fileUploadArea" class="file-upload-area">
                    <div class="file-upload-icon">ğŸ“</div>
                    <div class="file-upload-text">íŒŒì¼ì„ ì—¬ê¸°ì— ëŒì–´ë‹¤ ë†“ê±°ë‚˜<br>í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</div>
                    <div class="file-types">ì§€ì›: PDF, JPG, PNG, GIF</div>
                </div>
                <input type="file" id="fileInput" accept="application/pdf,image/jpeg,image/png,image/gif">
            </div>
            
            <div class="section">
                <div class="section-title"><span>ğŸ¨</span> ì£¼ì„ ë„êµ¬</div>
                <div class="tools-container">
                    <button id="pointerTool" class="tool-btn active" title="í¬ì¸í„°">ğŸ‘†</button>
                    <button id="penTool" class="tool-btn" title="íœ">âœï¸</button>
                    <button id="highlighterTool" class="tool-btn" title="í˜•ê´‘íœ">ğŸ–ï¸</button>
                    <button id="rectangleTool" class="tool-btn" title="ì‚¬ê°í˜•">â¬œ</button>
                    <button id="circleTool" class="tool-btn" title="ì›">â­•</button>
                    <input type="color" id="colorPicker" class="color-picker" value="#ff0000" title="ìƒ‰ìƒ ì„ íƒ">
                </div>
                <div class="stroke-width-container">
                    <span class="stroke-width-label">êµµê¸°:</span>
                    <input type="range" id="strokeWidth" class="stroke-width-slider" min="1" max="20" value="3">
                    <span id="strokeWidthValue">3px</span>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button id="undoBtn" class="btn btn-secondary" style="flex: 1;"><span>â†©ï¸</span> ë˜ëŒë¦¬ê¸°</button>
                    <button id="clearBtn" class="btn btn-danger" style="flex: 1;"><span>ğŸ—‘ï¸</span> ì „ì²´ ì§€ìš°ê¸°</button>
                </div>
                
                <div class="capture-section">
                    <button id="captureBtn" class="btn btn-success"><span>ğŸ“¸</span> í™”ë©´ ìº¡ì²˜ ì €ì¥</button>
                </div>
            </div>
        </aside>
        
        <main class="main-content">
            <div id="startScreen" class="start-screen">
                <div class="start-screen-icon">ğŸ“‘</div>
                <div class="start-screen-text">íŒŒì¼ì„ ì—…ë¡œë“œí•˜ë©´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤</div>
                <div class="start-screen-subtext">ì™¼ìª½ì—ì„œ ì„¸ì…˜ì„ ìƒì„±í•˜ê³  íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”</div>
            </div>
            
            <div id="pdfViewerContainer" class="pdf-viewer-container" style="display: none;">
                <div class="pdf-toolbar">
                    <button id="prevPageBtn" class="page-nav-btn" disabled>â—€</button>
                    <span id="pageInfo" class="page-info">1 / 1</span>
                    <button id="nextPageBtn" class="page-nav-btn" disabled>â–¶</button>
                </div>
                <div class="pdf-canvas-container">
                    <div class="canvas-wrapper">
                        <canvas id="pdfCanvas"></canvas>
                        <canvas id="drawCanvas"></canvas>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        let socket = null;
        let sessionId = null;
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 1;
        let currentTool = 'pointer';
        let isDrawing = false;
        let drawHistory = [];
        let currentPath = [];
        let startX, startY;
        let currentFileType = null;
        let currentImage = null;
        
        const pdfCanvas = document.getElementById('pdfCanvas');
        const drawCanvas = document.getElementById('drawCanvas');
        const pdfCtx = pdfCanvas.getContext('2d');
        const drawCtx = drawCanvas.getContext('2d');
        
        function toRatio(x, y) {
            return { x: x / drawCanvas.width, y: y / drawCanvas.height };
        }
        
        function fromRatio(rx, ry) {
            return { x: rx * drawCanvas.width, y: ry * drawCanvas.height };
        }
        
        function pathToRatio(path) {
            return path.map(p => toRatio(p.x, p.y));
        }
        
        function pathFromRatio(ratioPath) {
            return ratioPath.map(p => fromRatio(p.x, p.y));
        }
        
        function initSocket() {
            socket = io();
            socket.on('connect', () => {
                console.log('ì„œë²„ ì—°ê²°ë¨');
                if (sessionId) {
                    socket.emit('join-session', { sessionId, role: 'consultant' });
                }
            });
            socket.on('user-joined', (data) => {
                if (data.role === 'customer') {
                    updateStatus('connected', 'ê³ ê° ì—°ê²°ë¨');
                    showToast('ê³ ê°ì´ ì ‘ì†í–ˆìŠµë‹ˆë‹¤!', 'success');
                }
            });
            socket.on('user-left', (data) => {
                if (data.role === 'customer') {
                    updateStatus('waiting', 'ê³ ê° ì—°ê²° ëŠê¹€');
                    showToast('ê³ ê° ì—°ê²°ì´ ëŠê²¼ìŠµë‹ˆë‹¤', 'warning');
                }
            });
        }
        
        document.getElementById('createSessionBtn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/create-session', { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    sessionId = data.sessionId;
                    document.getElementById('shareLink').textContent = data.shareUrl;
                    document.getElementById('shareLinkContainer').classList.add('active');
                    initSocket();
                    socket.emit('join-session', { sessionId, role: 'consultant' });
                    showToast('ì„¸ì…˜ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                    document.getElementById('createSessionBtn').disabled = true;
                    document.getElementById('createSessionBtn').innerHTML = '<span>âœ…</span> ì„¸ì…˜ í™œì„±í™”ë¨';
                }
            } catch (error) {
                console.error('ì„¸ì…˜ ìƒì„± ì˜¤ë¥˜:', error);
                showToast('ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'warning');
            }
        });
        
        document.getElementById('copyLinkBtn').addEventListener('click', () => {
            const link = document.getElementById('shareLink').textContent;
            navigator.clipboard.writeText(link).then(() => {
                showToast('ë§í¬ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
            });
        });
        
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');
        
        fileUploadArea.addEventListener('click', () => fileInput.click());
        fileUploadArea.addEventListener('dragover', (e) => { e.preventDefault(); fileUploadArea.classList.add('dragover'); });
        fileUploadArea.addEventListener('dragleave', () => { fileUploadArea.classList.remove('dragover'); });
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileUpload(file);
        });
        fileInput.addEventListener('change', (e) => { if (e.target.files[0]) handleFileUpload(e.target.files[0]); });
        
        function handleFileUpload(file) {
            const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/gif'];
            if (!allowedTypes.includes(file.type)) {
                showToast('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤', 'warning');
                return;
            }
            
            if (file.type === 'application/pdf') {
                uploadFile(file, 'pdf');
            } else {
                uploadFile(file, 'image');
            }
        }
        
        async function uploadFile(file, type) {
            if (!sessionId) {
                showToast('ë¨¼ì € ì„¸ì…˜ì„ ìƒì„±í•´ì£¼ì„¸ìš”', 'warning');
                return;
            }
            const formData = new FormData();
            formData.append('file', file);
            formData.append('fileType', type);
            try {
                showToast('íŒŒì¼ ì—…ë¡œë“œ ì¤‘...', 'info');
                const response = await fetch(`/api/upload-file/${sessionId}`, { method: 'POST', body: formData });
                const data = await response.json();
                if (data.success) {
                    document.getElementById('currentFile').classList.add('active');
                    document.getElementById('currentFileName').textContent = file.name;
                    currentFileType = type;
                    drawHistory = [];
                    
                    if (type === 'pdf') {
                        await loadPDF(data.fileUrl);
                    } else {
                        await loadImage(data.fileUrl);
                    }
                    showToast('íŒŒì¼ì´ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
                }
            } catch (error) {
                console.error('íŒŒì¼ ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
                showToast('íŒŒì¼ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'warning');
            }
        }
        
        async function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    currentImage = img;
                    pdfDoc = null;
                    totalPages = 1;
                    currentPage = 1;
                    document.getElementById('startScreen').style.display = 'none';
                    document.getElementById('pdfViewerContainer').style.display = 'flex';
                    renderImage();
                    updatePageInfo();
                    resolve();
                };
                img.onerror = reject;
                img.src = url;
            });
        }
        
        function renderImage() {
            if (!currentImage) return;
            
            const maxWidth = 800;
            const maxHeight = 600;
            let width = currentImage.width;
            let height = currentImage.height;
            
            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (maxHeight / height) * width;
                height = maxHeight;
            }
            
            pdfCanvas.width = width;
            pdfCanvas.height = height;
            drawCanvas.width = width;
            drawCanvas.height = height;
            
            pdfCtx.drawImage(currentImage, 0, 0, width, height);
            redrawAll();
        }
        
        async function loadPDF(url) {
            try {
                pdfDoc = await pdfjsLib.getDocument(url).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                currentImage = null;
                document.getElementById('startScreen').style.display = 'none';
                document.getElementById('pdfViewerContainer').style.display = 'flex';
                await renderPage(currentPage);
                updatePageInfo();
            } catch (error) {
                console.error('PDF ë¡œë“œ ì˜¤ë¥˜:', error);
                showToast('PDFë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'warning');
            }
        }
        
        async function renderPage(pageNum) {
            const page = await pdfDoc.getPage(pageNum);
            const scale = 1.5;
            const viewport = page.getViewport({ scale });
            pdfCanvas.width = viewport.width;
            pdfCanvas.height = viewport.height;
            drawCanvas.width = viewport.width;
            drawCanvas.height = viewport.height;
            await page.render({ canvasContext: pdfCtx, viewport: viewport }).promise;
            redrawAll();
        }
        
        function updatePageInfo() {
            document.getElementById('pageInfo').textContent = `${currentPage} / ${totalPages}`;
            document.getElementById('prevPageBtn').disabled = currentPage <= 1 || currentFileType === 'image';
            document.getElementById('nextPageBtn').disabled = currentPage >= totalPages || currentFileType === 'image';
        }
        
        document.getElementById('prevPageBtn').addEventListener('click', () => {
            if (currentPage > 1 && currentFileType === 'pdf') {
                currentPage--;
                drawHistory = [];
                renderPage(currentPage);
                updatePageInfo();
                socket.emit('page-change', { sessionId, page: currentPage, totalPages });
            }
        });
        
        document.getElementById('nextPageBtn').addEventListener('click', () => {
            if (currentPage < totalPages && currentFileType === 'pdf') {
                currentPage++;
                drawHistory = [];
                renderPage(currentPage);
                updatePageInfo();
                socket.emit('page-change', { sessionId, page: currentPage, totalPages });
            }
        });
        
        const toolButtons = {
            pointer: document.getElementById('pointerTool'),
            pen: document.getElementById('penTool'),
            highlighter: document.getElementById('highlighterTool'),
            rectangle: document.getElementById('rectangleTool'),
            circle: document.getElementById('circleTool')
        };
        
        Object.entries(toolButtons).forEach(([tool, btn]) => {
            btn.addEventListener('click', () => {
                currentTool = tool;
                Object.values(toolButtons).forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                drawCanvas.style.cursor = tool === 'pointer' ? 'default' : 'crosshair';
            });
        });
        
        const colorPicker = document.getElementById('colorPicker');
        const strokeWidth = document.getElementById('strokeWidth');
        const strokeWidthValue = document.getElementById('strokeWidthValue');
        strokeWidth.addEventListener('input', (e) => { strokeWidthValue.textContent = `${e.target.value}px`; });
        
        function getCanvasCoords(e) {
            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;
            return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
        }
        
        drawCanvas.addEventListener('mousedown', (e) => {
            if (currentTool === 'pointer') return;
            isDrawing = true;
            const coords = getCanvasCoords(e);
            startX = coords.x;
            startY = coords.y;
            currentPath = [{ x: startX, y: startY }];
            
            const startRatio = toRatio(startX, startY);
            socket.emit('draw-start', { 
                sessionId, 
                tool: currentTool, 
                color: colorPicker.value, 
                width: parseInt(strokeWidth.value), 
                x: startRatio.x, 
                y: startRatio.y 
            });
        });
        
        drawCanvas.addEventListener('mousemove', (e) => {
            const coords = getCanvasCoords(e);
            
            if (currentTool === 'pointer' && sessionId) {
                const ratio = toRatio(coords.x, coords.y);
                socket.emit('pointer-move', { sessionId, x: ratio.x, y: ratio.y, visible: true });
            }
            
            if (!isDrawing) return;
            const color = colorPicker.value;
            const width = parseInt(strokeWidth.value);
            
            if (currentTool === 'pen' || currentTool === 'highlighter') {
                currentPath.push({ x: coords.x, y: coords.y });
                redrawAll();
                drawCtx.beginPath();
                drawCtx.strokeStyle = currentTool === 'highlighter' ? hexToRgba(color, 0.3) : color;
                drawCtx.lineWidth = currentTool === 'highlighter' ? width * 3 : width;
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                drawCtx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    drawCtx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                drawCtx.stroke();
                
                socket.emit('drawing', { 
                    sessionId, 
                    path: pathToRatio(currentPath), 
                    tool: currentTool, 
                    color: color, 
                    width: width 
                });
            } else if (currentTool === 'rectangle' || currentTool === 'circle') {
                redrawAll();
                drawShape(startX, startY, coords.x, coords.y, currentTool, color, width, true);
            }
        });
        
        drawCanvas.addEventListener('mouseup', (e) => {
            if (!isDrawing) return;
            isDrawing = false;
            const coords = getCanvasCoords(e);
            const color = colorPicker.value;
            const width = parseInt(strokeWidth.value);
            
            let drawingData = { tool: currentTool, color: color, width: width };
            
            if (currentTool === 'pen' || currentTool === 'highlighter') {
                drawingData.path = pathToRatio(currentPath);
            } else {
                const startRatio = toRatio(startX, startY);
                const endRatio = toRatio(coords.x, coords.y);
                drawingData.startX = startRatio.x;
                drawingData.startY = startRatio.y;
                drawingData.endX = endRatio.x;
                drawingData.endY = endRatio.y;
            }
            
            drawHistory.push(drawingData);
            redrawAll();
            socket.emit('draw-end', { sessionId, drawingData });
        });
        
        drawCanvas.addEventListener('mouseleave', () => {
            if (currentTool === 'pointer' && sessionId) {
                socket.emit('pointer-move', { sessionId, x: 0, y: 0, visible: false });
            }
        });
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawShape(x1, y1, x2, y2, shape, color, width, preview = false) {
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = width;
            drawCtx.lineCap = 'round';
            if (shape === 'rectangle') {
                drawCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            } else if (shape === 'circle') {
                const radiusX = Math.abs(x2 - x1) / 2;
                const radiusY = Math.abs(y2 - y1) / 2;
                const centerX = x1 + (x2 - x1) / 2;
                const centerY = y1 + (y2 - y1) / 2;
                drawCtx.beginPath();
                drawCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                drawCtx.stroke();
            }
        }
        
        function redrawAll() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            for (const item of drawHistory) {
                if (item.tool === 'pen' || item.tool === 'highlighter') {
                    const realPath = pathFromRatio(item.path);
                    drawCtx.beginPath();
                    drawCtx.strokeStyle = item.tool === 'highlighter' ? hexToRgba(item.color, 0.3) : item.color;
                    drawCtx.lineWidth = item.tool === 'highlighter' ? item.width * 3 : item.width;
                    drawCtx.lineCap = 'round';
                    drawCtx.lineJoin = 'round';
                    drawCtx.moveTo(realPath[0].x, realPath[0].y);
                    for (let i = 1; i < realPath.length; i++) {
                        drawCtx.lineTo(realPath[i].x, realPath[i].y);
                    }
                    drawCtx.stroke();
                } else {
                    const start = fromRatio(item.startX, item.startY);
                    const end = fromRatio(item.endX, item.endY);
                    drawShape(start.x, start.y, end.x, end.y, item.tool, item.color, item.width);
                }
            }
        }
        
        document.getElementById('undoBtn').addEventListener('click', () => {
            if (drawHistory.length > 0) {
                drawHistory.pop();
                redrawAll();
                socket.emit('undo-drawing', { sessionId });
            }
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            drawHistory = [];
            redrawAll();
            socket.emit('clear-drawings', { sessionId });
        });
        
        // í™”ë©´ ìº¡ì²˜ ê¸°ëŠ¥
        document.getElementById('captureBtn').addEventListener('click', () => {
            captureScreen();
        });
        
        function captureScreen() {
            const captureCanvas = document.createElement('canvas');
            captureCanvas.width = pdfCanvas.width;
            captureCanvas.height = pdfCanvas.height;
            const captureCtx = captureCanvas.getContext('2d');
            
            captureCtx.drawImage(pdfCanvas, 0, 0);
            captureCtx.drawImage(drawCanvas, 0, 0);
            
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            link.download = `ìƒë‹´í™”ë©´_${timestamp}.png`;
            link.href = captureCanvas.toDataURL('image/png');
            link.click();
            
            showToast('í™”ë©´ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
        }
        
        function updateStatus(status, text) {
            const badge = document.getElementById('statusBadge');
            const statusText = document.getElementById('statusText');
            badge.className = `status-badge ${status}`;
            statusText.textContent = text;
        }
        
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type} show`;
            setTimeout(() => { toast.classList.remove('show'); }, 3000);
        }
    </script>
</body>
</html>
